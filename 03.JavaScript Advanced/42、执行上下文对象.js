//1、全局执行上下文：创建全局对象->预处理->给this赋值->执行代码->销毁全局对象
//（1）打开页面，js代码执行前，创建window对象，确定window就是全局执行上下文对象
//（2）对全局执行上下文对象进行预处理
//找到使用var的变量声明语句，给全局执行上下文对象添加属性但不赋值
//找到使用function的函数声明语句，给全局执行上下文对象添加属性，值是函数
//给this进行赋值，将全局执行上下文对象赋值给this
//（3）正式执行全局代码
//（4）页面关闭，全局执行上下文对象销毁
//2、函数内执行上下文
//（1）调用函数时，函数内代码执行前，创建该函数的执行上下文
//（2）对函数执行上下文对象进行预处理
//将形参作为函数执行上下文对象的属性，并赋值
//给函数执行上下文对象添加属性arguments，并赋值
//找到函数内使用var的变量声明语句，给全局执行上下文对象添加属性但不赋值
//找到函数内使用function的函数声明语句，给全局执行上下文对象添加属性，值是函数
//给this进行赋值，将调用该函数的对象赋值给this
//（3）正式执行函数内语句
//（4）函数调用结束，函数内执行上下文对象被销毁
//注意：函数每调用1次，就创建1个执行上下文对象
//3、执行栈：执行上下文对象创建后，要放入执行栈才可执行（先进后出，后进先出）
//进栈：创建
//出栈：销毁
// //）（1）打开页面：全局执行上下文对象就创建
// function func(){
//     console.log("func被调用了",Math.random());
// };
// //调用函数 创建执行上下文对象 进栈，调用结束就出栈
// func();
// //调用函数 创建执行上下文对象 进栈，调用结束就出栈
// func();
// //调用函数 创建执行上下文对象 进栈，调用结束就出栈
// func();
// //关闭页面：全局执行上下文对象就出栈
// //断点调试

// function fun(n){
//     console.log('~',n);
//     if(n>=1){
//         fun(n-1);
//     }
//     console.log('~~',n);
// };
// fun(3);

//作用域和执行上下文对象的关系
//1、区别：
//（1）作用域：函数声明就确定
//（2）执行上下文对象：函数调用才创建，每调用1次就创建1次，调用结束就销毁，是动态的
//2、联系：
//（1）执行上下文对象从属于所在作用域
//（2）全局执行上下文对象作用域就是全局，函数执行上下文对象作用域就是局部

//闭包：特殊现象
//1、简介：函数B可访问函数A中的变量
//2、如何产生闭包：
//（1）A中嵌套B
//（2）B中可访问A中定义的数据（上层作用域中的变量）
function A(){
    //定义数据
    var a= 1,b=2;
    function B(){
        console.log('a+b=',a+b);
    };
    //（3）实现闭包闭环
    //方式1：作为返回值
    return B;
    // //方式2：函数B赋值给全局对象的属性
    // window.func = B;
    // //方式3：函数B作为事件的回调函数
    // document.onclick = B;
};
//调用函数A
var fn = A();
fn();
func();
//3、闭包和作用域以及垃圾回收的关系
//（1）闭包和作用域的关系：作用域只与声明位置有关：
//可以访问上层作用域数据、作用域只与函数声明位置有关，与函数调用位置无关
//（2）闭包和垃圾回收的关系：闭包延长了数据的生命周期
//4、闭包的缺点：常驻内存，增加了内存溢出（内存不够）的风险
//5、闭包的应用：
